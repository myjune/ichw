# 停机问题
- ## 证明原因
### 图灵希望通过证明停机问题来研究其他判定问题，即把证明某一判定问题转化为证明停机问题。若停机问题不可判定，则该判定问题不可判定，即不存在一种方法，在有穷步内按照一定程序判定该问题中的一公式是否常真。
- ## 证明方法
### 假设停机问题有解，即存在过程A(P,I)能判断程序P在输入I时是否可停机。若P输入I时可停机，A输出“停机”，反正输出“死循环”。
### 另外定义一个过程B，若A输出“停机”，则B死循环；若A输出“死循环”，则B停机。
### 将B作为A的输入。若B停机，则B死循环；若B死循环，则B停机。显然出现矛盾。
### 可见，不存在某个方法解决停机问题。
- ## 数学原理
### 高阶逻辑按照自身的逻辑推演，不一定能证明自己不是矛盾或者错误的。
# 二进制补码
### 补码是二进制负数表示法的一种，为二进制中的加减运算而引进。因为计算机只有0和1，没有+、—号，所以在二进制中用0与1表示正和负。给定码长N,求整数x的补码[x]。
- ## 表示
### [x]=x,0≤x≤2^(N-1)-1;2^N+x,-2^(N-1)-1≤x<0.
- ## 原理
### 若a,b∈Z,a-b能被m整除，即a≡b(mod m)对模m同余。在减法中，a,b相对于同余模m而言可看作是等价的。在上述负数的补码表示中，负数x与其补码2^(N-1)+x之差为2^(N-1),能被2^(N-1)整除，二者在减法运算中等价，故用补码表示保证了二进制加减运算结果的正确性。
# 浮点数表示
### +0     0000000000000000
### -0     1000000000000000
### +1.0   0011111100000000
### -1.0   1011111100000000
### 最大非规范化数   0000000011111111
### 最小非规范化数   1000000000000000、0000000000000000
### 最小规范化浮点数   0000000100000000、1000000100000000
### 最大规范化浮点数   0111111011111111、1111111011111111
### +∞     0111111100000000
### -∞     1111111100000000
### NaN    *1111111non zero（只要指数全为1，尾数不全是0即可,例如0111111110000000）
